# Tech Stack all in one ğŸŒ


## **Tech Stack** Overview ğŸ“š

Our organization leverages a modern set of technologies to ensure productivity, security, and scalability. We utilize a blend of development, operations, and quality tools to build reliable solutions for our clients and users.

---

## **Frontend Technologies** ğŸ–¥ï¸

1. **React** âš›ï¸
   - **Why**: React enables fast, dynamic, and scalable front-end development. We use it for building our Single Page Applications (SPAs).
   - **Additional Libraries**:
     - **Redux** ğŸ”„: For state management.
     - **Material-UI** ğŸ¨: A component library for building responsive and styled UI elements.
     - **React Router** ğŸš¦: For routing and navigation within the application.
2. **Vite** âš¡
   - **Why**: Vite is used for fast development builds and optimized bundling.

3. **TypeScript** ğŸ”¤
   - **Why**: Ensures type safety and reduces runtime errors in the codebase, improving the development experience and product quality.

On Plan:
**Next.js** ğŸ“¦
   - **Why**: Using Next.js for server-side rendering (SSR) and static site generation (SSG), which improves SEO and user experience.


---

## **Backend Technologies** ğŸŒ

1. **ASP.NET Core** âš™ï¸
   - **Why**: We use ASP.NET Core for high-performance, cross-platform backend services. Itâ€™s well-suited for enterprise-grade applications.

2. **Docker** ğŸ‹
   - **Why**: Containerization with Docker ensures that our applications are portable, isolated, and easy to deploy across environments.

On Plan:
**GraphQL** ğŸ”
   - **Why**: For flexible and optimized data fetching, we use GraphQL, allowing us to request only the data needed.

**Redis** ğŸ”´
   - **Why**: Redis is our go-to solution for caching and fast data retrieval.

---

## **Database Technologies** ğŸ’¾

1. **PostgreSQL** ğŸ—„ï¸
   - **Why**: A powerful, open-source relational database system we use to store structured data with ACID compliance.

On Plan: 
**MongoDB** ğŸ’
   - **Why**: For document-based storage, we use MongoDB, especially for handling unstructured data.

---

## **DevOps and Infrastructure** ğŸ”§

1. **Docker Compose** ğŸ”€
   - **Why**: We use Docker Compose to manage multi-container Docker applications, ensuring consistency across environments.
     
2. **CI/CD** ğŸš€
   - **GitHub Actions**: Automates testing and deployment pipelines.

4. **Cloud Infrastructure** â˜ï¸
   - **Why**: We utilize cloud infrastructure for best user expierience

---

## **Testing & Quality Assurance** âœ…

1. **Cypress** ğŸ§ª
   - **Why**: For end-to-end testing of our web applications.

3. **ESLint** ğŸ§
   - **Why**: We use ESLint to enforce coding standards and catch errors early in the development process.

4. **Prettier** âœ¨
   - **Why**: For consistent code formatting across our codebase.

On Plan:
**Jest** ğŸ§‘â€ğŸ’»
   - **Why**: For unit and integration testing in our JavaScript/TypeScript codebases.

---

## **Security Tools** ğŸ”
One Plan:
**OWASP ZAP** ğŸ•µï¸â€â™‚ï¸
   - **Why**: For security scanning of our web applications to identify vulnerabilities.

**SonarQube** ğŸ§©
   - **Why**: To ensure that our code is secure, maintainable, and high-quality by identifying bugs, vulnerabilities, and code smells.

---

## **Project Management Tools** ğŸ“‹

1. **Jira** ğŸ“Š
   - **Why**: We use Jira for tracking tasks


---

## **Monitoring & Logging** ğŸ“ˆ

To choose:
**Prometheus** ğŸ“Š
   - **Why**: For real-time monitoring of services and infrastructure metrics.

**Grafana** ğŸ“‰
   - **Why**: For visualizing and analyzing logs and metrics.

**Loggly** ğŸ“œ
   - **Why**: For centralized logging and monitoring, allowing us to catch issues in real-time.

---

## **External Integrations** ğŸ”—

1. **Brevo** ğŸ“§
   - **Why**: For email communications, including marketing and transactional emails, and SMS.

3. **QuestPDF** ğŸ“±
   - **Why**: For Pdf Generation on Enterprise Level

---

## **Conclusion** ğŸ‰

This stack powers our internal tools, public-facing websites, and client applications. We continuously evaluate and adopt new technologies to improve performance, scalability, and developer experience.
